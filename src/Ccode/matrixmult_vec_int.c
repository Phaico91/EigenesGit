/* code generated by ./matrixmult_codegen.py 256 int */
static void multiply_1overhang(Matrix *C, const Matrix *A, const Matrix *B,
                               size_t start_j)
{
  for (size_t i = 0; i < C->rows; i++)
  {
    __m256i r = _mm256_setzero_si256();
    for (size_t k = 0; k < A->columns; k++)
    {
      __m256i a = _mm256_set1_epi32(MA(i, k)),
              b = _mm256_set_epi32(MB(k, start_j),
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0),
              s = _mm256_mullo_epi32(a, b);
      r = _mm256_add_epi32(r, s);
    }
int*     out = (int*) &r;
    MC(i, start_j) += out[7];
  }
}

static void multiply_2overhang(Matrix *C, const Matrix *A, const Matrix *B,
                               size_t start_j)
{
  for (size_t i = 0; i < C->rows; i++)
  {
    __m256i r = _mm256_setzero_si256();
    for (size_t k = 0; k < A->columns; k++)
    {
      __m256i a = _mm256_set1_epi32(MA(i, k)),
              b = _mm256_set_epi32(MB(k, start_j),
                                MB(k, start_j + 1),
                                0,
                                0,
                                0,
                                0,
                                0,
                                0),
              s = _mm256_mullo_epi32(a, b);
      r = _mm256_add_epi32(r, s);
    }
int*     out = (int*) &r;
    MC(i, start_j) += out[7];
    MC(i, start_j + 1) += out[6];
  }
}

static void multiply_3overhang(Matrix *C, const Matrix *A, const Matrix *B,
                               size_t start_j)
{
  for (size_t i = 0; i < C->rows; i++)
  {
    __m256i r = _mm256_setzero_si256();
    for (size_t k = 0; k < A->columns; k++)
    {
      __m256i a = _mm256_set1_epi32(MA(i, k)),
              b = _mm256_set_epi32(MB(k, start_j),
                                MB(k, start_j + 1),
                                MB(k, start_j + 2),
                                0,
                                0,
                                0,
                                0,
                                0),
              s = _mm256_mullo_epi32(a, b);
      r = _mm256_add_epi32(r, s);
    }
int*     out = (int*) &r;
    MC(i, start_j) += out[7];
    MC(i, start_j + 1) += out[6];
    MC(i, start_j + 2) += out[5];
  }
}

static void multiply_4overhang(Matrix *C, const Matrix *A, const Matrix *B,
                               size_t start_j)
{
  for (size_t i = 0; i < C->rows; i++)
  {
    __m256i r = _mm256_setzero_si256();
    for (size_t k = 0; k < A->columns; k++)
    {
      __m256i a = _mm256_set1_epi32(MA(i, k)),
              b = _mm256_set_epi32(MB(k, start_j),
                                MB(k, start_j + 1),
                                MB(k, start_j + 2),
                                MB(k, start_j + 3),
                                0,
                                0,
                                0,
                                0),
              s = _mm256_mullo_epi32(a, b);
      r = _mm256_add_epi32(r, s);
    }
int*     out = (int*) &r;
    MC(i, start_j) += out[7];
    MC(i, start_j + 1) += out[6];
    MC(i, start_j + 2) += out[5];
    MC(i, start_j + 3) += out[4];
  }
}

static void multiply_5overhang(Matrix *C, const Matrix *A, const Matrix *B,
                               size_t start_j)
{
  for (size_t i = 0; i < C->rows; i++)
  {
    __m256i r = _mm256_setzero_si256();
    for (size_t k = 0; k < A->columns; k++)
    {
      __m256i a = _mm256_set1_epi32(MA(i, k)),
              b = _mm256_set_epi32(MB(k, start_j),
                                MB(k, start_j + 1),
                                MB(k, start_j + 2),
                                MB(k, start_j + 3),
                                MB(k, start_j + 4),
                                0,
                                0,
                                0),
              s = _mm256_mullo_epi32(a, b);
      r = _mm256_add_epi32(r, s);
    }
int*     out = (int*) &r;
    MC(i, start_j) += out[7];
    MC(i, start_j + 1) += out[6];
    MC(i, start_j + 2) += out[5];
    MC(i, start_j + 3) += out[4];
    MC(i, start_j + 4) += out[3];
  }
}

static void multiply_6overhang(Matrix *C, const Matrix *A, const Matrix *B,
                               size_t start_j)
{
  for (size_t i = 0; i < C->rows; i++)
  {
    __m256i r = _mm256_setzero_si256();
    for (size_t k = 0; k < A->columns; k++)
    {
      __m256i a = _mm256_set1_epi32(MA(i, k)),
              b = _mm256_set_epi32(MB(k, start_j),
                                MB(k, start_j + 1),
                                MB(k, start_j + 2),
                                MB(k, start_j + 3),
                                MB(k, start_j + 4),
                                MB(k, start_j + 5),
                                0,
                                0),
              s = _mm256_mullo_epi32(a, b);
      r = _mm256_add_epi32(r, s);
    }
int*     out = (int*) &r;
    MC(i, start_j) += out[7];
    MC(i, start_j + 1) += out[6];
    MC(i, start_j + 2) += out[5];
    MC(i, start_j + 3) += out[4];
    MC(i, start_j + 4) += out[3];
    MC(i, start_j + 5) += out[2];
  }
}

static void multiply_7overhang(Matrix *C, const Matrix *A, const Matrix *B,
                               size_t start_j)
{
  for (size_t i = 0; i < C->rows; i++)
  {
    __m256i r = _mm256_setzero_si256();
    for (size_t k = 0; k < A->columns; k++)
    {
      __m256i a = _mm256_set1_epi32(MA(i, k)),
              b = _mm256_set_epi32(MB(k, start_j),
                                MB(k, start_j + 1),
                                MB(k, start_j + 2),
                                MB(k, start_j + 3),
                                MB(k, start_j + 4),
                                MB(k, start_j + 5),
                                MB(k, start_j + 6),
                                0),
              s = _mm256_mullo_epi32(a, b);
      r = _mm256_add_epi32(r, s);
    }
int*     out = (int*) &r;
    MC(i, start_j) += out[7];
    MC(i, start_j + 1) += out[6];
    MC(i, start_j + 2) += out[5];
    MC(i, start_j + 3) += out[4];
    MC(i, start_j + 4) += out[3];
    MC(i, start_j + 5) += out[2];
    MC(i, start_j + 6) += out[1];
  }
}


void matrix_multiplication_vectorized(Matrix *C,const Matrix *A,const Matrix *B)
{
  EXPECTED_EQUALITY(A->columns,B->rows);
  EXPECTED_EQUALITY(C->rows,A->rows);
  EXPECTED_EQUALITY(C->columns,B->columns);

  /* square parts of matrix */
  if (C->columns > 7)
  {
    for (size_t i = 0; i < C->rows; i++)
    {
      for (size_t j = 0; j < C->columns - 7; j += 8)
      {
        __m256i r = _mm256_setzero_si256();

        for (size_t k = 0; k < A->columns; k++)
        {
          __m256i a = _mm256_set1_epi32(MA(i, k)),
                  b = _mm256_set_epi32(MB(k, j),
                                      MB(k, j + 1),
                                      MB(k, j + 2),
                                      MB(k, j + 3),
                                      MB(k, j + 4),
                                      MB(k, j + 5),
                                      MB(k, j + 6),
                                      MB(k, j + 7)),
                  s = _mm256_mullo_epi32(a, b);
          r = _mm256_add_epi32(r, s);
        }
    int*     out = (int*) &r;
        MC(i, j) = out[7];
        MC(i, j + 1) += out[6];
        MC(i, j + 2) += out[5];
        MC(i, j + 3) += out[4];
        MC(i, j + 4) += out[3];
        MC(i, j + 5) += out[2];
        MC(i, j + 6) += out[1];
        MC(i, j + 7) += out[0];
      }
    }
  }

  if (C->columns % 8 != 0)
  {
    const size_t ohang = C->columns - (C->columns % 8);
    switch (C->columns % 8)
    {
      case 1:
        multiply_1overhang(C, A, B, ohang);
        break;
      case 2:
        multiply_2overhang(C, A, B, ohang);
        break;
      case 3:
        multiply_3overhang(C, A, B, ohang);
        break;
      case 4:
        multiply_4overhang(C, A, B, ohang);
        break;
      case 5:
        multiply_5overhang(C, A, B, ohang);
        break;
      case 6:
        multiply_6overhang(C, A, B, ohang);
        break;
      case 7:
        multiply_7overhang(C, A, B, ohang);
        break;
      default: assert (false); //something went wrong
    }
  }
}

void matrix_multiplication_transposed_vectorized(Matrix *C,const Matrix *A,
                                                 const Matrix *B)
{
  Matrix *M;

  EXPECTED_EQUALITY(A->columns,B->rows);
  EXPECTED_EQUALITY(C->rows,A->rows);
  EXPECTED_EQUALITY(C->columns,B->columns);

  M = matrix_transposition(B);

  /* square parts of matrix */
  if (C->columns > 7)
  {
    for (size_t i = 0; i < C->rows; i++)
    {
      for (size_t j = 0; j < C->columns - 7; j += 8)
      {
        __m256i r = _mm256_setzero_si256();

        for (size_t k = 0; k < A->columns; k++)
        {
          __m256i a = _mm256_set1_epi32(MA(i, k)),
                  b = _mm256_set_epi32(MM(j, k),
                                      MM(j + 1, k),
                                      MM(j + 2, k),
                                      MM(j + 3, k),
                                      MM(j + 4, k),
                                      MM(j + 5, k),
                                      MM(j + 6, k),
                                      MM(j + 7, k)),
                  s = _mm256_mullo_epi32(a, b);
          r = _mm256_add_epi32(r, s);
        }
    int*     out = (int*) &r;
        MC(i, j) = out[7];
        MC(i, j + 1) += out[6];
        MC(i, j + 2) += out[5];
        MC(i, j + 3) += out[4];
        MC(i, j + 4) += out[3];
        MC(i, j + 5) += out[2];
        MC(i, j + 6) += out[1];
        MC(i, j + 7) += out[0];
      }
    }
  }

  if (C->columns % 8 != 0)
  {
    const size_t ohang = C->columns - (C->columns % 8);
    switch (C->columns % 8)
    {
      case 1:
        multiply_1overhang(C, A, B, ohang);
        break;
      case 2:
        multiply_2overhang(C, A, B, ohang);
        break;
      case 3:
        multiply_3overhang(C, A, B, ohang);
        break;
      case 4:
        multiply_4overhang(C, A, B, ohang);
        break;
      case 5:
        multiply_5overhang(C, A, B, ohang);
        break;
      case 6:
        multiply_6overhang(C, A, B, ohang);
        break;
      case 7:
        multiply_7overhang(C, A, B, ohang);
        break;
      default: assert (false); //something went wrong
    }
  }
  matrix_delete(M);
}
